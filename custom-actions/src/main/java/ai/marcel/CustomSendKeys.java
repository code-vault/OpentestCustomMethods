package ai.marcel;

import org.getopentest.appium.core.SwipingAction;
import org.getopentest.logging.Logger;
import org.openqa.selenium.By;
import org.openqa.selenium.Keys;
import org.openqa.selenium.WebElement;

import io.appium.java_client.MobileElement;
import io.appium.java_client.android.AndroidDriver;
import io.appium.java_client.android.nativekey.AndroidKey;
import io.appium.java_client.ios.IOSDriver;
import io.appium.java_client.ios.IOSElement;

public class CustomSendKeys extends SwipingAction {

    protected void hideKeyboard(String keyName, String platform) {
        try {
            if (driver instanceof IOSDriver) {
            	if(!platform.equalsIgnoreCase("iOS"))
            		throw new RuntimeException(String.format(
                            "Failed hiding keyboard, expected platform - iOS, found \"%s\"",
                            platform));
                if (config.getBoolean("appium.hideKeyboardIos", Boolean.TRUE)) {
                    IOSDriver iosDriver = (IOSDriver) driver;
                    if (keyName != null) {
                    	 driver.getKeyboard().sendKeys(Keys.valueOf(keyName.toUpperCase()));
                    } else {
                        // Not sure what is the right way to consistently hide the
                        // keyboard in iOS. The hideKeyboard method is unacceptably
                        // slow or unstable in some cases.

                        iosDriver.hideKeyboard();
                    }
                }
            } else if (driver instanceof AndroidDriver) {
            	if(!platform.equalsIgnoreCase("Android"))
            		throw new RuntimeException(String.format(
                            "Failed hiding keyboard, expected platform - Android, found \"%s\"",
                            platform));
                if (config.getBoolean("appium.hideKeyboardAndroid", Boolean.TRUE)) {
                    AndroidDriver androidDriver = (AndroidDriver) driver;
                    androidDriver.hideKeyboard();
                }
            }
        } catch (Exception ex) {
            // We don't want to throw this exception, because it's cause might
            // be that the keyboard was not on the screen to start with
            Logger.warning("There was an error while attempting to hide the keyboard", ex);
        }
    }
    
    @Override
    public void run() {
        super.run();

        By locator = this.readLocatorArgument("locator", null);
        String text = this.readStringArgument("text", null);
        Boolean clearContent = this.readBooleanArgument("clearContent", this.readBooleanArgument("clear", Boolean.FALSE));
        String hideKeyboardiOS = this.readStringArgument("iOSHideKeyboard", null);
        String hideKeyboardAndroid =  this.readStringArgument("androidHideKeyboard", null);
        Boolean useKeyboardService = this.readBooleanArgument("useKeyboardService", Boolean.FALSE);
        Boolean sendToActiveElement = this.readBooleanArgument("sendToActiveElement", Boolean.FALSE);
        String keyCode = this.readStringArgument("keyCode", null);
        String hideKeyboard = (hideKeyboardiOS != null) ? hideKeyboardiOS : hideKeyboardAndroid;

        try {
            WebElement element = null;

            if (locator != null) {
                this.swipeAndCheckElementVisible(locator, this.getSwipeOptions());
                element = this.getElement(locator);
            } else if (sendToActiveElement) {
                try {
                    element = driver.switchTo().activeElement();
                } catch (Exception exc) {
                    throw new RuntimeException(
                            "We failed to retrieve the active element. Before using the \"sendToActiveElement\" argument, "
                            + "please make sure to tap the element (or perform the steps necessary to make it active).");
                }
            }

            if (clearContent && element != null) {
                element.clear();
            }

            if (useKeyboardService) {
                driver.getKeyboard().sendKeys(text);
            } else {
            	if (element != null) {
            		if(keyCode != null) {
            			if(driver instanceof AndroidDriver) {
            				AndroidDriver androidDriver = (AndroidDriver) driver;
            				AndroidKey key = AndroidKey.valueOf(keyCode.toUpperCase());
            				androidDriver.pressKeyCode(key.getCode());
            			} else if(driver instanceof IOSDriver) {
            				Keys key = Keys.valueOf(keyCode);
            				driver.getKeyboard().pressKey(key);
            			}
            		}else {
						if(text != null)
							if(driver instanceof AndroidDriver)
								element.sendKeys(text);
							else if(driver instanceof IOSDriver) {
								IOSElement e = (IOSElement) element;
								e.setValue(text);
							}
                	} 
                } else {
                    throw new RuntimeException(
                            "Can't perform action. You must either specify the locator of the element to send "
                            + "the keys to, or set one of the \"sendToActiveElement\" or \"useKeyboardService\" "
                            + "arguments to true.");
                }
            }

            if (hideKeyboard != null) {
            	String platform = hideKeyboard.substring("hideKeyboard".length());
                this.hideKeyboard(hideKeyboard, platform);
            }
        } catch (Exception ex) {
            if (locator != null) {
                throw new RuntimeException(String.format(
                        "Failed sending keys \"%s\" to element %s",
                        text,
                        locator.toString()), ex);
            } else {
                throw new RuntimeException(String.format(
                        "Failed sending keys \"%s\"",
                        text), ex);
            }
        }
    }
}